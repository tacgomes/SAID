package classifier;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;

import model.Document;
import classifier.cluster.PartitionalCluster;
import classifier.proxmeasure.EuclideanDistance;
import classifier.proxmeasure.ProximityMeasure;

/**
 * Class that implements the k-means algorithm:
 * <pre>
 *  1. Select K points as the initial centroids
 * 	2. Repeat
 * 	3.   Form K clusters by assigning all the points to the closest centroid
 * 	4.   Recompute the centroid of each cluster
 * 	5. Until the centroids don't change
 * </pre>
 * 
 * @author	Tiago Gomes
 * @version	1.0
 */
public class Kmeans {

	public static final int UNIFORM_CENTERS	 	 = 1;
	public static final int DISTRIBUTED_CENTERS	 = 2;
	public static final int SMART_CENTERS 		 = 3;

	public static final int JUST_REMOVE			 = 1;
	public static final int SPLIT_BIGGEST		 = 2;
	public static final int SPLIT_MOST_DISPERSED = 3;

	/** List of data points. */
	private ArrayList<DataPoint> dpoints_;

	/** List of clusters. */
	private ArrayList<PartitionalCluster> clusters_;

	/** Proximity measure in use. */
	private ProximityMeasure proxMeasure_;

	/** Heuristic to choose initial seeds. */
	private int seedingHeuristic_;

	/** Empty cluster handle mode. */
	private int emptyClusterHandleMode_;

	/** Number of trials for kmeans++ */
	private static final int N_KMPP_TRIALS = 2;

	/** Indicates if kmeans converged */
	private boolean itConverged_;

	/** Number of iterations of the last kmeans run */
	private int nIters_;

	/** Number of moves of the last kmeans iteration */
	private int moves_;

	/** Indicates if the generated log should be printed. */
	private boolean showKmeansLog_;


	/**
	 * Creates a new Kmeans instance.
	 * 
	 * @param	dpoints	List of data points to run the kmeans algorithm.
	 */
	public Kmeans(ArrayList<DataPoint> dpoints) {
		dpoints_ 	            = dpoints;
		showKmeansLog_          = true;
		seedingHeuristic_       = UNIFORM_CENTERS;
		emptyClusterHandleMode_ = JUST_REMOVE;
	}

	/**
	 * Creates a new Kmeans instance specifying if the log generated by kmeans should
	 * be printed.
	 * 
	 * @param	dpoints			List of data points to run the kmeans algorithm.
	 * @param	showKmeansLog	Indicates if generated log should be printed.
	 */
	public Kmeans(ArrayList<DataPoint> dpoints, boolean showKmeansLog) {
		dpoints_ 	      	    = dpoints;
		showKmeansLog_    	    = showKmeansLog;
		seedingHeuristic_ 	    = UNIFORM_CENTERS;
		emptyClusterHandleMode_ = JUST_REMOVE;
	}

	/**
	 * Runs the kmeans algorithm.
	 * 
	 * @param	k	The desired number of clusters.
	 */
	public void run(int k) {
		init(k);
		runUntilConverges();
	}

	/**
	 * Runs a given number of iterations.
	 * 
	 * @param	k		The desired number of clusters.
	 * @param 	iters	The number iterations to run.
	 */
	public void run(int k, int iters) {
		init(k);
		for (int i = 0; i < iters; i++) {
			runOneIteration_();
			if (itConverged_ == true) {
				break;
			}
		}
		handleEmptyClusters();
	}

	/**
	 * Prepares to running the kmeans algorithm.
	 * 
	 * @param	k	The desired number of clusters.
	 */
	private void init(int k) {
		Classifier.setLastAgorithmUsed(Classifier.KMEANS);
		proxMeasure_ = Classifier.getProximityMeasure();

		if (showKmeansLog_) {
			System.out.println("\nRunning Kmeans: k=" + k);
		}

		clusters_ = new ArrayList<PartitionalCluster>(k);

		switch (seedingHeuristic_) { 
			case UNIFORM_CENTERS: 
				chooseUniformCentroids(k);
				break;
			case DISTRIBUTED_CENTERS:
				chooseSpaceDistributedCentroids(k);
				break;
			case SMART_CENTERS:
				chooseSmartCentroids(k);
				break;
		}

		nIters_ = 0;
		itConverged_ = false;
	}
	
	/**
	 * Runs one iteration of kmeans.
	 */
	public void runOneIteration() {
		runOneIteration_();
		handleEmptyClusters();
	}
	
	/**
	 * Runs one iteration of kmeans.
	 */
	private void runOneIteration_() {
		moves_ = 0;

		// assign each data point to the nearest cluster
		for (int i = 0; i < dpoints_.size(); i++) {
			assignToNearestCluster(dpoints_.get(i));
		}

		// update each centroid
		for (PartitionalCluster c: clusters_) {
			c.updateCentroid();
		}
	
		if (moves_ == 0) {
			itConverged_ = true;
			if (seedingHeuristic_ == DISTRIBUTED_CENTERS) {
				handleEmptyClusters();
			}
		}

		nIters_++;

		if (showKmeansLog_) {
			System.out.println("        iteration " + nIters_ + ": " + moves_ + " moves");
		}	
	}

	/**
	 * Runs kmeans until converges.
	 */
	public void runUntilConverges() {
		while (itConverged_ == false) {
			runOneIteration_();
		}
		handleEmptyClusters();
	}

	/**
	 * Chooses a number of initial centroids uniformly at random from the data points.
	 * Ensures that every cluster will have a different initial centroid.
	 * 
	 * @param	k	Initial number of centroids to choose.
	 */
	private void chooseUniformCentroids(int k) {
		if (showKmeansLog_) {
			System.out.println("        choosing uniform centroids");
		}

		Random rand = new Random();
		ArrayList<Integer> indexes = new ArrayList<Integer>(k);

		int count = 0;
		while (count < k) {
			int index = Math.abs(rand.nextInt()) % dpoints_.size();
			if (indexes.contains(index) == false) {
				count++;
				indexes.add(index);
			}
		}

		for (int i: indexes) {
			clusters_.add(new PartitionalCluster(dpoints_.get(i).getVector()));
		}
	}

	/**
	 * Chooses a number of initial centroids uniformly distributed in the space.
	 * 
	 * @param	k	Initial number of centroids to choose.
	 */
	private void chooseSpaceDistributedCentroids(int k) {
		if (showKmeansLog_) {
			System.out.println("        choosing space distributed centroids");
		}

		float[] mins = new float[Document.vectorSize()];
		float[] maxs = new float[Document.vectorSize()];

		Arrays.fill(mins, Float.MAX_VALUE);
		Arrays.fill(maxs, Float.MIN_VALUE);

		for (DataPoint dp: dpoints_) {
			float[] v = dp.getVector();
			for (int i = 0; i < v.length; i++) {
				float value = v[i];
				if (value > maxs[i]) {
					maxs[i] = value;
				}
				if (value < mins[i]) {
					mins[i] = value;
				}
			}
		}
			
		float centroid[] = new float[Document.vectorSize()];
		for (int n = 1; n <= k; n++) {
			for (int i = 0; i < centroid.length; i++) {
				centroid[i] = ((maxs[i] - mins[i]) / (k + 1) * n) + mins[i];
			}
			clusters_.add(new PartitionalCluster(centroid));
		}		
	}

	/**
	 * Chooses a number of initial different centroids randomly from the data set
	 * using the k-means++ heuristic by David Arthur and Sergei Vassilvitskii.
	 * 
	 * Algorithm:
	 * <pre>
	 * 	1. One centroid is chosen randomly.
	 *  2. Now repeat numCentroids-1 times:
	 *      - Repeat N_KMPP_TRIALS times:
	 *          - Add a point x with probability proportional to the distance squared from x
	 *            to the closest existing centroid
	 *      - Add the point chosen above that results in the smallest potential.
	 * </pre>   
	 *
	 * @param	k	Initial number of centroids to choose.
	 */
	private void chooseSmartCentroids(int k) {
		if (showKmeansLog_) {
			System.out.println("        choosing smart centroids: #trials=" + N_KMPP_TRIALS);
		}

		ProximityMeasure eucDist = new EuclideanDistance();
		Random rand = new Random();
		ArrayList<Integer> indexes = new ArrayList<Integer>(k);
		float closestDistSq[] = new float[dpoints_.size()];

		// Choose one random center
		int index = Math.abs(rand.nextInt()) % dpoints_.size();
		indexes.add(index);

		// Calculate potential and set the closestDistSq values
		float currentPot = 0;
		for (int i = 0; i < dpoints_.size(); i++) {
			float dist = eucDist.getProximity(dpoints_.get(i).getVector(),
					dpoints_.get(index).getVector());
			closestDistSq[i] = dist * dist;
			currentPot = currentPot + closestDistSq[i];
		}

		// Choose the remaining k-1 centroids
		for (int numCentroids = 1; numCentroids < k; numCentroids++) {
			// Repeat several trials
			float bestNewPot = -1;
			int bestNewIndex = -1;

			for (int trial = 0; trial < N_KMPP_TRIALS; trial++) {
				float randVal = rand.nextFloat() * currentPot;
				for (index = 0; index < dpoints_.size() - 1; index++) {
					if (randVal <= closestDistSq[index]) {
						break;
					}
					randVal = randVal - closestDistSq[index];
				}

				// Compute the new potential
				float newPot = 0;
				for (int i = 0; i < dpoints_.size(); i++) {

					float dist = eucDist.getProximity(dpoints_.get(i).getVector(),
							dpoints_.get(index).getVector());

					if (eucDist.isBetter(dist * dist, closestDistSq[i])) {
						newPot = newPot + dist * dist;
					} else {
						newPot = newPot + closestDistSq[i];
					}
				}
				// Store the best result
				if (bestNewPot < 0 || newPot < bestNewPot) {
					bestNewPot = newPot;
					bestNewIndex = index;
				}
			}
			
			currentPot = bestNewPot;

			// set the closestDistSq values
			for (int i = 0; i < dpoints_.size(); i++) {
				float dist = eucDist.getProximity(dpoints_.get(i).getVector(),
						dpoints_.get(bestNewIndex).getVector());
				if (eucDist.isBetter(dist * dist, closestDistSq[i])) {
					closestDistSq[i] = dist * dist;
				}

			}
			indexes.add(bestNewIndex);
		}

		for (int i: indexes) {
			clusters_.add(new PartitionalCluster(dpoints_.get(i).getVector()));
		}
	}

	/**
	 * Assign a data point to the cluster with nearest centroid.
	 *
	 * @param	dp	Data point to be assigned.
	 */
	private void assignToNearestCluster(DataPoint dp) {
		PartitionalCluster nearestCluster = null;
		float bestProx = proxMeasure_.worstProximity();

		for (PartitionalCluster c: clusters_) {
			float prox = proxMeasure_.getProximity(dp.getVector(), c.getCentroid());
			if (proxMeasure_.isBetter(prox, bestProx)) {
				bestProx = prox;
				nearestCluster = c;
			}
		}

		if (nIters_ == 0) {
			// in the first iteration, the oldCluster is null
			dp.setCluster(nearestCluster);
			nearestCluster.addDataPoint(dp);
			moves_++;
		}
		else {
			PartitionalCluster oldCluster = dp.getCluster();
			if (oldCluster != nearestCluster) {
				oldCluster.removeDataPoint(dp);
				dp.setCluster(nearestCluster);
				nearestCluster.addDataPoint(dp);
				moves_++;
			}
		}
	}

	/**
	 * Removes empty clusters from the list of clustes.
	 */
	public void handleEmptyClusters() {
		if (showKmeansLog_) {
			System.out.println("        removing empty clusters: mode=" 
					+ emptyClusterHandleMode_);
		}

		int i = 0;
		while (i < clusters_.size()) {
			if (clusters_.get(i).size() == 0) {
				clusters_.remove(i);
				if (emptyClusterHandleMode_ == JUST_REMOVE) {
					// removing is enough
				}
				else {
					PartitionalCluster c = null;
					if (emptyClusterHandleMode_ == SPLIT_BIGGEST) {
						c = Classifier.getClusterWithBiggestSize(clusters_);
					}
					else {
						c = Classifier.getClusterWithBiggestSSE(clusters_);
					}
					if (c.size() == 1) {
						break;
					}
					Kmeans kmeans = new Kmeans(c.getDataPoints(), false);
					kmeans.setSeedingHeuristic(seedingHeuristic_);
					kmeans.run(2);
					clusters_.remove(c);
					clusters_.add(kmeans.getClusters().get(0));
					clusters_.add(kmeans.getClusters().get(1));
					itConverged_ = false;
					runUntilConverges();
				}
			}
			else {
				i++;
			}
		}
	}

	/**
	 * Returns the seeding heuristic used in the last run of kmeans.
	 * 
	 * @return	The seeding heuristic.
	 */
	public int getSeedingHeuristic() {
		return seedingHeuristic_;
	}

	/**
	 * Sets the seeding heuristic.
	 * 
	 * @param	seedingHeuristic	The seeding heuristic.
	 */
	public void setSeedingHeuristic(int seedingHeuristic) {
		seedingHeuristic_ = seedingHeuristic;
	}

	/**
	 * Sets the mode to handle empty clusters.
	 * 
	 * @param	emptyClusterHandleMode	The mode.
	 */
	public void setEmptyClusterHandleMode(int emptyClusterHandleMode) {
		emptyClusterHandleMode_ = emptyClusterHandleMode;
	}

	/**
	 * Checks if kmeans converged or not.
	 * 
	 * @return	True if kmeans converged, otherwise false.
	 */
	public boolean itConverged() {
		return itConverged_;
	}

	/** 
	 * Returns the number of iterations of the last run of kmeans.
	 * 
	 * @return	Number of iterations of the last run of kmeans.
	 */
	public int getIterationsNumber() {
		return nIters_;
	}

	/**
	 * Returns a list of the created clusters.
	 * 
	 * @return	List of the created clusters.
	 */
	ArrayList<PartitionalCluster> getClusters() {
		return clusters_;
	}

}
